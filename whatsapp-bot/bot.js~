const { default: makeWASocket, useMultiFileAuthState, delay } = require('@whiskeysockets/baileys')
const qrcode = require('qrcode-terminal')
const Anthropic = require('@anthropic-ai/sdk')
const fs = require('fs')
const path = require('path')

// â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DEBOUNCE_MS      = 10000
const MEMORY_DIR       = path.join(__dirname, 'memory')
const LOG_FILE         = path.join(__dirname, 'logs', 'messages.log')
const MAX_HISTORY      = 20   // keep last N messages per user (user + assistant pairs)
const RECONNECT_DELAY  = 5000 // ms before attempting reconnect

// â”€â”€â”€ SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const secretsPath = path.join(__dirname, '..', '.secrets')
const secrets = fs.readFileSync(secretsPath, 'utf-8')
const apiKey = secrets.match(/ANTHROPIC_API_KEY=(.+)/)[1].trim()
const claude = new Anthropic({ apiKey })

if (!fs.existsSync(MEMORY_DIR)) fs.mkdirSync(MEMORY_DIR, { recursive: true })
if (!fs.existsSync(path.dirname(LOG_FILE))) fs.mkdirSync(path.dirname(LOG_FILE), { recursive: true })

// â”€â”€â”€ LOGGING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function logMessage(sender, direction, text) {
    const timestamp = new Date().toISOString()
    const line = `[${timestamp}] [${direction}] [${sender}]: ${text}\n`
    fs.appendFileSync(LOG_FILE, line, 'utf-8')
    console.log(line.trim())
}

// â”€â”€â”€ MEMORY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getMemoryPath(sender) {
    return path.join(MEMORY_DIR, `${sender}.json`)
}

function loadConversation(sender) {
    const filePath = getMemoryPath(sender)
    if (fs.existsSync(filePath)) {
        return JSON.parse(fs.readFileSync(filePath, 'utf-8'))
    }
    return []
}

function saveConversation(sender, messages) {
    // Trim to last MAX_HISTORY messages before saving
    const trimmed = messages.slice(-MAX_HISTORY)
    fs.writeFileSync(getMemoryPath(sender), JSON.stringify(trimmed, null, 2), 'utf-8')
}

// â”€â”€â”€ CLAUDE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SYSTEM_PROMPT = `
Eres Camila, la asistente virtual del Dr. Juan Diego VelÃ¡squez por WhatsApp. El Dr. es mÃ©dico especialista en medicina tradicional china (MTC), acupuntura y medicina integrativa, con consulta en Pereira, Colombia.

Hablas de manera casual, cÃ¡lida y cercana â€” como un amigo que sabe de salud, no como un robot. Mensajes cortos, uno a la vez. Nada de listas ni menÃºs. Haz preguntas abiertas y deja que la persona cuente su historia con sus propias palabras.

Nunca menciones que eres una IA o un bot. Si te preguntan, di que eres la asistente del Dr. VelÃ¡squez.

---

CÃ“MO FLUYE LA CONVERSACIÃ“N:

1. SALUDA y pregunta su nombre. Luego pregunta quÃ© problema o molestia lo trajo aquÃ­.
   â†’ "Â¡Hola! Soy Camila, asistente del Dr. Juan Diego VelÃ¡squez. Â¿Con quiÃ©n tengo el gusto de hablar?"

2. ESCUCHA con empatÃ­a genuina. Valida cÃ³mo se siente. Forma un rapport real antes de hablar de cualquier servicio. Pregunta cuÃ¡nto tiempo lleva asÃ­, cÃ³mo afecta su vida diaria, quÃ© ha intentado antes.

3. CONECTA con su deseo. Cuando sea natural, pregÃºntale cÃ³mo serÃ­a su vida si eso cambiara.
   â†’ "Si pudieras recuperarte de verdad, Â¿quÃ© serÃ­a lo primero que harÃ­as?"

4. OFRECE la soluciÃ³n. Solo despuÃ©s de entender su situaciÃ³n, presenta el servicio mÃ¡s relevante para su caso   â†’ "Mira [Nombre], con lo que me cuentas, creo que te podria servir una consulta con el doctor. Que dia estarias disponible?"

---

SERVICIOS:
Formulario autodiagnostico de fibromialgia:
  https://docs.google.com/forms/d/e/1FAIpQLSeZVrcR2_ls7eIrq9AjEKqTeIqnsiLbt3dXkXDFmUFzALVBeA/viewform?usp=send_form

ğŸ“ PROGRAMA DE FIBROMIALGIA (30 dÃ­as) â€” Inicio 2 de marzo
- 2 consultas mÃ©dicas personalizadas
- 8 clases en vivo sobre fibromialgia (con grabaciÃ³n)
- Meditaciones guiadas y coaching individual
- PrescripciÃ³n de ejercicio adaptada al dolor
- Grupo de acompaÃ±amiento por WhatsApp
Precios:
  Â· USD: $77
  Â· Colombia: $297.000 COP
  Â· MÃ©xico: $1.342 MXN
  Â· Chile: $67.000 CLP
- Se puede reservar con el 20% y pagar el resto antes del inicio
- MÃ¡s info: https://juandiegovelasquez.com/

ğŸ“‹ CONSULTA VIRTUAL (40 min)
Link para agenar laconsulta https://encuadrado.com/p/dr-juan-diego-velasquez
    consulta completa
Los precios se pueden en la pagina

Consulta virtual (20 min)
    Por si ya tienen diagnostico y neceistan una consulta sobre algo puntual

Consultas presenciales
Link para agendar la consulta: https://calendly.com/juandiegovelasquezmd/consulta-med-intregrativa
Direccion: Torre MÃ©dica 1, Megacentro Pinares:, Cra. 18 #12 - 75 Oficina 203, Pereira, Risaralda

    Primera consulta presencial (Medicina Integrativa + Acupuntura)
    1+ hora - $130.000 COP
    EvaluaciÃ³n completa y primer tratamiento

    SesiÃ³n de seguimiento presencial
    1 hora - $120.000 COP
    Continuidad terapÃ©utica personalizada

informacion de pago:
Llave Bre-B: @0078537958
Cuenta ahorros Bancolombia: 85742832550

ğŸ“… Â¿CÃ³mo agendar tu consulta presencial?

Paso 1 â€” Elige tu fecha y hora ğŸ—“ï¸
Ingresa a mi calendario y selecciona el horario que mejor se acomode a ti:
ğŸ‘‰ https://calendly.com/juandiegovelasquezmd/consulta-med-intregrativa

Paso 2 â€” Confirma tu cita con el pago del 50% ğŸ’³
Una vez agendado, realiza el pago de la mitad de tu consulta para confirmar tu espacio.
Primera consulta: $65.000 COP (50% de $130.000)
SesiÃ³n de seguimiento: $60.000 COP (50% de $120.000)
Te compartimos los datos de pago por WhatsApp una vez agendado.

Paso 3 â€” Â¡Listo! ğŸ‰
RecibirÃ¡s tu confirmaciÃ³n y nos vemos en consulta.
Lbro gratuito fibromialgia:
  ğŸ“– https://dr-juan-diego-velasquez.tiendup.com/p/fibromialgia-guia-integrativa-para-recuperar-tu-salud

---


MANEJO DE OBJECIONES:

- "Ya probÃ© de todo" â†’ "Eso es lo que nos dicen casi todos antes de conocer al Dr. Su enfoque es completamente distinto, trata la causa raÃ­z, no solo los sÃ­ntomas. Â¿Le darÃ­as 10 minutos para explicarte?"

reglas:
- No uses emojis
- No escribas parrafos largos
`

async function askClaude(sender, userMessage, retries = 3) {
    const history = loadConversation(sender)
    const isReturning = history.length > 0

    if (!isReturning) {
        history.push({
            role: 'user',
            content: `[Nota interna: esta persona podrÃ­a tener una conversaciÃ³n previa. Si su mensaje no parece un primer contacto, saluda brevemente y retoma natural.] ${userMessage}`
        })
    } else {
        history.push({ role: 'user', content: userMessage })
    }

    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const response = await claude.messages.create({
                model: 'claude-sonnet-4-5',
                max_tokens: 1024,
                system: SYSTEM_PROMPT,
                messages: history
            })

            const reply = response.content.find(b => b.type === 'text')?.text || ''
            history.push({ role: 'assistant', content: reply })
            saveConversation(sender, history)
            return reply

        } catch (err) {
            console.error(`âŒ Attempt ${attempt}/${retries} failed:`, err.message)
            if (attempt === retries) {
                return 'Disculpa, tuve un problemita tÃ©cnico. Puedes escribirme de nuevo en un momento?'
            }
            await delay(attempt * 2000)
        }
    }
}

// â”€â”€â”€ ANTI-BAN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function sendHumanReply(sock, sender, text) {
    const thinkDelay = Math.floor(Math.random() * 2000) + 1000
    const typeDelay  = Math.min(text.length * 30, 5000)

    await delay(thinkDelay)
    await sock.sendPresenceUpdate('composing', sender)
    await delay(typeDelay)
    await sock.sendPresenceUpdate('paused', sender)
    await sock.sendMessage(sender, { text })
}

// â”€â”€â”€ MAIN BOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let isConnecting = false

async function startBot() {
    const { state, saveCreds } = await useMultiFileAuthState('auth')
    const sock = makeWASocket({ auth: state })

    sock.ev.on('creds.update', saveCreds)

    // â”€â”€â”€ Seed history from WhatsApp sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    sock.ev.on('messaging-history.set', ({ messages }) => {
        for (const msg of messages) {
            const jid = msg.key.remoteJid
            if (!jid || jid.endsWith('@g.us')) continue

            const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text
            if (!text) continue

            const role = msg.key.fromMe ? 'assistant' : 'user'
            const history = loadConversation(jid)

            // avoid duplicates
            const alreadyExists = history.some(h => h.content === text && h.role === role)
            if (!alreadyExists) {
                history.push({ role, content: text })
            }

            saveConversation(jid, history)
        }
        console.log('ğŸ“š History seeded from WhatsApp sync')
    })

    sock.ev.on('connection.update', ({ connection, qr, lastDisconnect }) => {
        if (qr) qrcode.generate(qr, { small: true })

        if (connection === 'open') {
            isConnecting = false
            console.log('âœ… Bot connected!')
        }

        if (connection === 'close') {
            const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== 401
            if (shouldReconnect && !isConnecting) {
                isConnecting = true
                console.log(`ğŸ”„ Connection closed. Reconnecting in ${RECONNECT_DELAY / 1000}s...`)
                setTimeout(() => { isConnecting = false; startBot() }, RECONNECT_DELAY)
            } else if (!shouldReconnect) {
                console.log('ğŸš« Logged out. Please delete the auth folder and restart to scan QR again.')
            }
        }
    })

    const pendingMessages = {}

    sock.ev.on('messages.upsert', async ({ messages, type }) => {
        // Only handle genuinely new incoming messages
        if (type !== 'notify') return

        const msg = messages[0]

        // Ignore stale messages replayed on startup (offline sync)
        const msgTimestamp = (msg.messageTimestamp || 0) * 1000
        if (Date.now() - msgTimestamp > 30_000) return

        // Ignore group messages
        const sender = msg.key.remoteJid
        if (sender.endsWith('@g.us')) return

        // If it's a message YOU sent manually, save it to history so Claude stays in context
        if (msg.key.fromMe) {
            const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text
            if (text) {
                const history = loadConversation(sender)
                history.push({ role: 'assistant', content: text })
                saveConversation(sender, history)
                logMessage(sender.replace(/@s\.whatsapp\.net/, ''), 'OUT-MANUAL', text)
            }
            return
        }

        const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text
        if (!text) return

        const senderNumber = sender.replace(/@s\.whatsapp\.net/, '')

        // Debounce â€” collect messages for DEBOUNCE_MS then reply once
        if (pendingMessages[sender]) {
            clearTimeout(pendingMessages[sender].timer)
            pendingMessages[sender].texts.push(text)
        } else {
            pendingMessages[sender] = { texts: [text] }
        }

        pendingMessages[sender].timer = setTimeout(async () => {
            const combined = pendingMessages[sender].texts.join(' ')
            delete pendingMessages[sender]

            logMessage(senderNumber, 'IN', combined)

            try {
                const reply = await askClaude(sender, combined)
                await sendHumanReply(sock, sender, reply)
                logMessage(senderNumber, 'OUT', reply)
            } catch (err) {
                console.error('âŒ Error:', err)
            }
        }, DEBOUNCE_MS)
    })
}

startBot()
